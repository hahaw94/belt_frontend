# 首页地图摄像头聚合功能实现总结

## 实现内容

为首页地图添加了摄像头聚合功能，类似地图配置页面的实现，主要包括：

### 1. 视觉展示
- ✅ 在地图上聚合位置相近的摄像头（容差20像素）
- ✅ 在聚合摄像头图标右上角显示数字徽章，显示摄像头数量
- ✅ 聚合摄像头有独特的视觉效果（红色渐变光晕）
- ✅ 鼠标悬停时有增强的视觉反馈

### 2. 交互功能
- ✅ 点击聚合摄像头打开视频弹窗
- ✅ 弹窗标题栏显示当前摄像头索引（例如：1 / 3）
- ✅ 弹窗两侧添加左右切换按钮（圆形按钮，带箭头）
- ✅ 点击左右按钮可切换聚合中的其他摄像头
- ✅ 切换时自动加载对应摄像头的视频流
- ✅ 到达边界时按钮自动禁用

## 修改的文件

### `belt/src/views/HomeView.vue`

#### 1. 模板部分修改

**地图摄像头渲染（第21-57行）**
```vue
<!-- 从渲染 cameraData 改为渲染 clusteredCameras -->
<div
  v-for="(cluster, index) in clusteredCameras"
  :key="cluster.id"
  class="map-camera-icon"
  :class="[
    `camera-${index + 1}`,
    { 'clustered': cluster.cameras.length > 1 }
  ]"
  @click.stop="showCameraPopup(cluster)"
>
  <!-- 聚合数量标识 -->
  <div v-if="cluster.cameras.length > 1" class="cluster-count">
    {{ cluster.cameras.length }}
  </div>
  
  <div class="camera-label">
    {{ cluster.cameras.length > 1 ? `${cluster.cameras[0].device_name} 等${cluster.cameras.length}个` : cluster.cameras[0].device_name }}
  </div>
</div>
```

**视频弹窗增强（第492-534行）**
```vue
<div class="custom-modal-header">
  <h3 class="custom-modal-title">
    <!-- LIVE标识 -->
    <span v-if="currentStreamUrl && isPlaying" class="live-badge">
      <span class="live-dot-small"></span>
      LIVE
    </span>
    <!-- 聚合摄像头信息徽章 -->
    <span v-if="currentCluster && currentCluster.cameras && currentCluster.cameras.length > 1" class="cluster-info-badge">
      {{ currentClusterIndex + 1 }} / {{ currentCluster.cameras.length }}
    </span>
  </h3>
  <button class="custom-modal-close" @click="closeCameraPopup">&times;</button>
</div>

<!-- 聚合摄像头切换按钮 -->
<div v-if="currentCluster && currentCluster.cameras && currentCluster.cameras.length > 1" class="cluster-nav-buttons">
  <button 
    class="cluster-nav-btn prev-btn" 
    @click="switchToPrevCamera"
    :disabled="currentClusterIndex === 0"
  >
    <span class="nav-arrow">‹</span>
  </button>
  <button 
    class="cluster-nav-btn next-btn" 
    @click="switchToNextCamera"
    :disabled="currentClusterIndex === currentCluster.cameras.length - 1"
  >
    <span class="nav-arrow">›</span>
  </button>
</div>
```

#### 2. 脚本部分修改

**新增状态（第767-769行）**
```javascript
// 聚合摄像头状态
const currentCluster = ref(null)
const currentClusterIndex = ref(0)
```

**新增计算属性（第1416-1462行）**
```javascript
// 相机聚合计算 - 将位置相同或接近的相机聚合在一起
const clusteredCameras = computed(() => {
  if (!cameraData.value || cameraData.value.length === 0) return []
  
  const clusters = []
  const processed = new Set()
  const tolerance = 20 // 位置容差，像素为单位
  
  cameraData.value.forEach((camera, index) => {
    if (processed.has(index)) return
    
    const cluster = {
      id: `cluster_${clusters.length}`,
      cameras: [camera],
      position_x: camera.position_x,
      position_y: camera.position_y,
      camera_angle: camera.camera_angle
    }
    
    processed.add(index)
    
    // 查找位置相近的其他相机
    cameraData.value.forEach((otherCamera, otherIndex) => {
      if (processed.has(otherIndex) || index === otherIndex) return
      
      const distance = Math.sqrt(
        Math.pow(camera.position_x - otherCamera.position_x, 2) +
        Math.pow(camera.position_y - otherCamera.position_y, 2)
      )
      
      if (distance <= tolerance) {
        cluster.cameras.push(otherCamera)
        processed.add(otherIndex)
      }
    })
    
    clusters.push(cluster)
  })
  
  return clusters
})
```

**修改和新增函数（第1630-1690行）**
```javascript
// 显示摄像头弹窗 - 支持聚合
const showCameraPopup = (cluster) => {
  if (!cluster) return
  
  // 保存聚合信息
  currentCluster.value = cluster
  currentClusterIndex.value = 0
  
  // 设置当前摄像头为第一个
  const firstCamera = cluster.cameras ? cluster.cameras[0] : cluster
  currentCameraPopup.value = firstCamera
  cameraPopupVisible.value = true
  
  // 自动播放对应的视频流
  autoPlayCameraStream(firstCamera)
}

// 切换到上一个摄像头
const switchToPrevCamera = () => {
  if (!currentCluster.value || !currentCluster.value.cameras) return
  if (currentClusterIndex.value <= 0) return
  
  currentClusterIndex.value--
  const camera = currentCluster.value.cameras[currentClusterIndex.value]
  currentCameraPopup.value = camera
  
  // 自动播放新的视频流
  autoPlayCameraStream(camera)
}

// 切换到下一个摄像头
const switchToNextCamera = () => {
  if (!currentCluster.value || !currentCluster.value.cameras) return
  if (currentClusterIndex.value >= currentCluster.value.cameras.length - 1) return
  
  currentClusterIndex.value++
  const camera = currentCluster.value.cameras[currentClusterIndex.value]
  currentCameraPopup.value = camera
  
  // 自动播放新的视频流
  autoPlayCameraStream(camera)
}

// 关闭摄像头弹窗 - 清理聚合状态
const closeCameraPopup = () => {
  cameraPopupVisible.value = false
  currentCameraPopup.value = {}
  currentCluster.value = null
  currentClusterIndex.value = 0
  stopStream()
}
```

#### 3. 样式部分修改

**聚合数量标识样式（第4025-4045行）**
```css
.cluster-count {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 22px;
  height: 22px;
  background: linear-gradient(135deg, rgba(245, 108, 108, 0.9), rgba(220, 38, 127, 1));
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: bold;
  border: 2px solid rgba(0, 255, 255, 0.8);
  box-shadow: 0 0 12px rgba(245, 108, 108, 0.8);
  z-index: 10;
  pointer-events: none;
  text-shadow: 0 0 3px rgba(245, 108, 108, 0.8);
}
```

**聚合摄像头样式增强（第4047-4066行）**
```css
.map-camera-icon.clustered {
  filter:
    drop-shadow(0 0 12px rgba(245, 108, 108, 0.7))
    drop-shadow(0 0 6px rgba(255, 255, 255, 0.4))
    contrast(1.3)
    brightness(1.25)
    saturate(1.5);
}

.map-camera-icon.clustered:hover {
  transform: scale(1.35);
  filter:
    drop-shadow(0 0 20px rgba(245, 108, 108, 1.0))
    drop-shadow(0 0 10px rgba(255, 255, 255, 0.7))
    contrast(1.4)
    brightness(1.35)
    saturate(1.6);
  box-shadow: 0 0 25px rgba(245, 108, 108, 0.9);
}
```

**聚合信息徽章样式（第4155-4167行）**
```css
.cluster-info-badge {
  display: inline-block;
  background: linear-gradient(135deg, rgba(245, 108, 108, 0.8), rgba(220, 38, 127, 0.9));
  color: white;
  font-size: 14px;
  font-weight: bold;
  padding: 4px 12px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 255, 0.5);
  box-shadow: 0 0 10px rgba(245, 108, 108, 0.6);
  text-shadow: 0 0 3px rgba(245, 108, 108, 0.8);
}
```

**切换按钮样式（第4169-4231行）**
```css
.cluster-nav-buttons {
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  transform: translateY(-50%);
  display: flex;
  justify-content: space-between;
  padding: 0 10px;
  pointer-events: none;
  z-index: 1000;
}

.cluster-nav-btn {
  width: 48px;
  height: 48px;
  background: rgba(0, 20, 40, 0.85);
  border: 2px solid rgba(0, 212, 255, 0.6);
  border-radius: 50%;
  color: #00d4ff;
  font-size: 32px;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  pointer-events: auto;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(5px);
}

.cluster-nav-btn:hover:not(:disabled) {
  background: rgba(0, 212, 255, 0.2);
  border-color: #00d4ff;
  transform: scale(1.1);
  box-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
}

.cluster-nav-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  border-color: rgba(100, 100, 100, 0.5);
  color: rgba(100, 100, 100, 0.8);
}
```

## 功能特性

### 聚合算法
- 使用欧几里得距离算法计算摄像头之间的距离
- 容差阈值：20像素
- 自动将距离小于容差的摄像头聚合为一组

### 视觉设计
- **普通摄像头**：青色光晕效果
- **聚合摄像头**：红色渐变光晕效果，更显眼
- **数量标识**：红色渐变圆形徽章，白色数字
- **信息徽章**：在弹窗标题栏显示当前索引和总数

### 交互体验
- 点击聚合摄像头自动打开第一个摄像头的视频流
- 通过左右按钮轻松切换聚合中的其他摄像头
- 切换时自动加载新摄像头的视频流
- 边界处理：第一个/最后一个时禁用对应按钮
- 按钮有悬停和点击反馈效果

## 测试建议

1. **聚合测试**
   - 在地图配置页面将多个摄像头放置在相近位置（距离<20像素）
   - 切换到首页，验证是否正确显示聚合标识

2. **切换测试**
   - 点击聚合摄像头，打开视频弹窗
   - 验证是否显示正确的索引信息
   - 点击左右按钮，验证是否正确切换摄像头
   - 验证视频流是否自动加载

3. **边界测试**
   - 在第一个摄像头时，验证左按钮是否被禁用
   - 在最后一个摄像头时，验证右按钮是否被禁用

4. **视觉测试**
   - 验证聚合摄像头的红色光晕效果
   - 验证数量标识的显示
   - 验证悬停效果是否正常

## 代码质量

- ✅ 无 linter 错误
- ✅ 遵循现有代码风格
- ✅ 添加了详细的注释
- ✅ 添加了控制台日志用于调试

## 问题修复记录

### 视频切换时的 flv.js 错误修复（2025-10-26）

**问题描述**
当切换聚合摄像头时，出现运行时错误：
```
ERROR: Cannot read properties of null (reading 'flushStashedSamples')
TypeError: Cannot read properties of null (reading 'flushStashedSamples')
    at TransmuxingController._onIOComplete
    at IOController._onLoaderComplete
    at WebSocketLoader._onWebSocketClose
```

**问题原因**
- 前一个视频流的连接还没有正确关闭和清理
- 就立即尝试加载新的视频流
- 导致 flv.js 内部状态冲突

**解决方案**

1. **添加切换状态管理**
```javascript
const isSwitchingCamera = ref(false) // 是否正在切换摄像头
```

2. **优化切换函数，添加资源清理步骤**
```javascript
const switchToPrevCamera = async () => {
  if (isSwitchingCamera.value) return // 防止重复点击
  
  try {
    isSwitchingCamera.value = true
    
    // 先停止当前播放，避免资源冲突
    stopStream()
    
    // 等待300ms确保资源完全释放
    await new Promise(resolve => setTimeout(resolve, 300))
    
    // 切换到新摄像头
    currentClusterIndex.value--
    const camera = currentCluster.value.cameras[currentClusterIndex.value]
    currentCameraPopup.value = camera
    
    // 自动播放新的视频流
    await autoPlayCameraStream(camera)
  } catch (error) {
    console.error('切换摄像头失败:', error)
    ElMessage.error('切换摄像头失败')
  } finally {
    isSwitchingCamera.value = false
  }
}
```

3. **改进按钮禁用逻辑**
```vue
<button 
  class="cluster-nav-btn prev-btn" 
  @click="switchToPrevCamera"
  :disabled="currentClusterIndex === 0 || isSwitchingCamera"
  :title="isSwitchingCamera ? '切换中...' : '上一个摄像头'"
>
```

4. **添加切换中的视觉反馈**
```vue
<!-- 旋转的加载图标 -->
<span v-if="isSwitchingCamera" class="switching-indicator">⟳</span>
{{ currentClusterIndex + 1 }} / {{ currentCluster.cameras.length }}
```

```css
.switching-indicator {
  display: inline-block;
  animation: rotate 1s linear infinite;
  font-size: 16px;
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
```

5. **优化 stopStream 函数**
```javascript
const stopStream = () => {
  // 清空流地址
  currentStreamUrl.value = ''
  isPlaying.value = false
  
  // 增加 playerKey 强制销毁并重新创建播放器组件，确保资源完全释放
  playerKey.value++
  
  console.log('停止播放，playerKey:', playerKey.value)
}
```

**修复效果**
- ✅ 切换摄像头时不再出现 flv.js 错误
- ✅ 防止快速连续点击导致的资源冲突
- ✅ 添加切换中的视觉反馈，提升用户体验
- ✅ 改善错误处理和日志输出

### 增强错误处理和日志（2025-10-26 更新）

为了解决持续出现的 `RuntimeException: undefined` 错误，进一步增强了错误处理机制：

**1. autoPlayCameraStream 函数增强**
- 添加所有参数的空值检查
- 为每个关键步骤添加详细日志
- 避免在 setTimeout 中访问可能已改变的对象引用
- 为 setTimeout 内部添加 try-catch 保护
- 所有可能为 undefined 的属性都使用可选链操作符 `?.`

```javascript
// 保存流名称，避免闭包问题
const streamDeviceName = matchedStream.device_name || '未知设备'

// setTimeout 内部添加错误保护
setTimeout(() => {
  try {
    if (inputStreamUrl.value) {
      currentStreamUrl.value = inputStreamUrl.value.trim()
      isPlaying.value = true
      playerKey.value++
      ElMessage.success(`正在播放 ${streamDeviceName} 的视频流`)
    }
  } catch (err) {
    console.error('autoPlayCameraStream: 播放时出错:', err)
    ElMessage.error('播放视频流失败')
  }
}, 150)
```

**2. getAvailableStreams 函数增强**
- 确保 response.data 是数组类型
- 在 map 之前过滤 null/undefined 元素
- 为 map 内部添加 try-catch
- map 之后再次过滤失败的转换结果
- 所有属性访问都提供默认值

```javascript
const streams = Array.isArray(response.data) ? response.data : []
availableStreams.value = streams.filter(stream => stream != null).map(stream => {
  try {
    return {
      id: stream.board_id || stream.id,
      device_name: stream.device_name || stream.board_name || '未知设备',
      stream_id: stream.stream_id || '',
      status: stream.status || 'unknown',
      play_urls: stream.play_urls || {},
      start_time: stream.start_time || '',
      last_active_time: stream.last_active_time || ''
    }
  } catch (mapError) {
    console.error('转换流数据失败:', mapError, stream)
    return null
  }
}).filter(stream => stream != null)
```

**3. fixStreamUrl 函数增强**
- 添加参数类型检查
- 为所有可能的错误点添加 try-catch
- 降级处理也包裹在 try-catch 中
- 添加详细的日志输出

```javascript
const fixStreamUrl = (url) => {
  if (!url || typeof url !== 'string') {
    console.warn('fixStreamUrl: URL为空或不是字符串:', url)
    return url
  }
  
  try {
    const urlObj = new URL(url)
    // ... 处理逻辑
  } catch (error) {
    console.error('fixStreamUrl: URL解析失败:', error, 'URL:', url)
    try {
      // 降级处理
    } catch (replaceError) {
      console.error('fixStreamUrl: 字符串替换也失败:', replaceError)
    }
    return url
  }
}
```

**4. 关键改进点**
- ✅ 所有对象属性访问都使用可选链 `?.`
- ✅ 所有可能为空的变量都有默认值
- ✅ 避免在异步回调中访问可能已改变的引用
- ✅ 多层 try-catch 保护，确保错误不会向上传播
- ✅ 详细的日志输出，便于排查问题

**5. 测试步骤**
1. 打开浏览器开发者工具的 Console 面板
2. 点击聚合摄像头打开视频弹窗
3. 观察控制台日志，查看详细的执行流程
4. 点击左右切换按钮
5. 查看是否有任何错误信息
6. 如果仍有错误，查看控制台日志定位具体步骤

## 日期

2025-10-26

